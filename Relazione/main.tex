

\documentclass[12pt]{article}
\usepackage[italian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{algorithm2e}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\usepackage{fancyhdr}
\usepackage[final]{pdfpages}


\pagestyle{fancy}
\fancyhf{}
\lhead{Relazione Progetto Laboratorio di Game Programming}


\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Univeristà degli studi di Udine}\\[1.5cm] % Name of your university/college

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Progetto di Laboratorio di Game Programming}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Autore:}\\
Fedrigo Mattia\\
Maestrutti Andrea\\
Mauro Luca\\
Not Simone 139032\\

\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} 
\emph{email:}\\
not.simone@spes.uniud.it\\
maestrutti.andrea@spes.uniud.it
\end{flushright}
\end{minipage}\\[2cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
%John \textsc{Smith}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[width=50mm]{uniud.png}\\[1cm] % Include a department/university logo - this will require the graphicx package
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}
\tableofcontents
\clearpage
\section{Il problema}
Il progetto d’esame relativo all’insegnamento di Laboratorio di Game Programming (LGP) consiste nell’implementazione di un videogioco utilizzando il framework di sviluppo CoronaSDK. Il tema del videogioco è l'ambiente. 

Ai fini dello sviluppo è stato utilizzato il linguaggio di programmazione "Lua", che è un linguaggio utilizzato prevalentemente per scripting.
\\\\
\textbf{NOTA}: Il codice, con i relativi moduli, è stato scritto interamente da noi. Si assicura che nulla è stato copiato o scaricato da progetti già esistenti. Le immagini sono state realizzate utilizzando il software "Adobe Illustrator".

\section{Meccaniche di gioco}
\subsection{Spiegazione del gioco}
Il gioco realizzato è intitolato \textbf{Save The Ocean}, ed ha come scopo quello di liberare il fondale marino dalla spazzatura lasciata dall'uomo a bordo di un sommergibile, preservano così il pianeta e le creature dell'oceano.

La spazzatura è rappresentata da bottigliette di plastica e barili pieni di petrolio.
\\

La sconfitta si verifica in due casi distinti: ogni qualvolta non si raccolga l'immondizia, oppure quando il sommergibile va a sbattere contro uno scoglio. Nel primo caso, non raccogliendo gli oggetti la "vita del mare" diminuisce e quando quest'ultima raggiunge la fine la partita finisce (raccogliendo gli oggetti, però, la vita del mare aumenta); nel secondo caso, la partita termina immediatamente. 
 

\subsection{Interazione con l'utente}
 
L'utente dovrà raccogliere tutti i rifiuti presenti nell'ambiente. Ad ognuno corrisponde un punteggio differente: con la raccolta delle bottigliette di plastica si guadagnano 50 punti; mentre con la raccolta dei barili 100 punti. 
\\Il gioco, inoltre, tiene traccia del punteggio massimo che viene raggiunto nelle varie sessioni.
Con il passare del tempo la velocità di gioco aumenta fino a raggiungere e mantenere la velcità massima, in particolare ogni 30 secondi viene aggiunto 0.25 alla velcoità attuale. Con l'aumentare della velocità, aumenta anche la difficoltà quindi il giocatore dovrà essere il più abile possibile a raccogliere gli oggetti. 


Quando la partita termina compare la scritta "Game Over", ed il giocatore può decidere se tornare al menù principale oppure ricominciare da capo la partita. 

\section{Gestione dell’efficieza nella generazione delle hitbox
per gli ostacoli}

Dato che gli ostacoli devono avere una \textbf{hitbox} consistente con la loro forma, viene utillizzata la funzione di libreria 
graphics.newOutline(), per creare automaticamente il poligono della hitbox basandosi sulle sezioni col parmetro dell'ostacolo "alpha = 0" (trasparente).
\\

Tale operazione richiede una certa elaborazione sull’immagine ed è onerosa in termini di prestazioni. E'stato dunque inserito un sistema 
dinamico di cache, che utilizza la table outlineCache dove vengono salvati gli output della funzione "graphics.newOutline()", utilizzando come stringa di riferimento per la tabella il nome del path dove risiede l’asset salvato, es. outlineCache [assetPathString] = graphics.newOutline().
Dunque ogni volta che è necessario creare l’outline di un ostacolo viene prima verificata la sua presenza in cache: se presente viene 
estratto da li; se non presente viene generato, salvato in cache, e poi letto.
\\

Il sistema è dinamico quindi non si basa 
su una tabella di nomi gia definita ma viene creata all’occorrenza e per qualsiasi nome di percorso.

\section{Librerie}
In questo capitolo verranno illustrate brevemente le principali liberire implementate, utilizzate per il corretto funzionamento del gioco:
\\
\\\\
\begin{itemize}
    \item Librerie Interne: 
    \begin{itemize}
        \item Window: questa libreria si occupa della gestione di apertura e chiusura delle finestre con la relativa distruzione quando viene premuto il pulsante "x". Si occupa inoltre di formattare il testo nella posizione corretta all'interno dello schermo.
         \item Ui: liberira utilizzata per il posizionamento dei pulsanti e adesivi all'interno dell'interfaccia. Ha 3 modalità:
            \begin{itemize}
                \item posizionamento statico 
                \item compattare i pulsanti sotto un pulsante "master" che si occupa di compattare e scompattare il menù di gioco
                \item apertura e chiusura con sostituzione del pulsante master
            \end{itemize}
        \item Tabulator: si occupa di posizionare, come se si stesse creando una tabella, un determinato set di elementi, necessario per mostrare i vari elementi selezionabili per skin e highscores. Tramite una callback, che prende come parametro l'oggetto che è stato toccato, è possibile eseguire alcune operazioni su di esso, come per esempio selezionarlo o acquistarlo. Questa libreria offre due funzionalità legate all'oggetto di riferimento:
        \begin{itemize}
            \item stampare un etichetta sull’ oggetto
            \item stampare un altro oggetto sull'oggetto stesso
        \end{itemize}
         \item Audio: esegue azioni sull'audio globale del gioco. Viene invocata nel main per caricare le impostazioni audio dal salvataggio al caricamento del gioco.
         
    \end{itemize}
    
    \item Librerie legate alle scene: vengono invocate tramite un showOverlay e nascoste tramite un hideOverlay. Il sistema overlay scarica completamente la scena dalla memoria in modo automatico, tuttavia dato che queste scene possono essere usate molte volte nel giro di poco tempo ha senso tenerle caricate, e quindi viene impostato il recicle = true.
        \begin{itemize}
            \item Submarine: libreria che dipende dalle librerie window, save data, tabulator. Permette di selezionare le skin dei sottomarini. All’apertura genera una finestra con window, carica dal salvataggio i dati relativi ai sottomarini e costruisce una tavola da passare al tabulatore. Quest'ultimo genera tutti i sottomarini con i relativi prezzi (per quelli che non sono ancora stati acquistati). 
            \item Menu.Scores: libreria che dipende da window, save data e tabulator. Libreria la cui funzione è quella di caricare una tabella alla volta man mano che l'utente gioca. 
            \item Menu.About:  libreria che dipende da: window. Viene utilizzata una semplice immagine con del testo sopra la window. 
        \end{itemize}
    
\end{itemize}
\section{Implementazione}
Il gioco è stato implementato utilizzando il framework coronaSDK, e scrivendo il codice in "Lua". 


Il codice è stato diviso in moduli per avere una visione più completa del programma e per poter apportare modifiche più agevolemente. 
Ogni modulo del gioco ha un template ben definito:
\\\\


\includegraphics[width=145mm]{module_template.png}\\


\subsection{Scene}
Il gioco è strutturato in "scene", gestite utilizzando il \textbf{composer}, una libreria che fornisce agli sviluppatori  un modo semplice per creare e passare da una scena all'altra. Il ciclo di vita di composer inizia all'interno di main.lua. Tuttavia, main.lua stesso non è una scena del composer: viene semplicemente utilizzato per inizializzarlo, quindi avvia la prima scena tramite composer.gotoScene(). In questa chiamata, si specifica il nome della scena (file) da caricare. 

Quattro diverse funzioni gestiscono gli eventi generati dal Composer: create, show, hide and destroy.
La funzione "scene:create()" viene utilizzata per creare tutti gli oggetti, caricare in memoria e settare i display object, inclusi pulsanti, testo, grafica e altri oggetti che dovrebbero essere visualizzati prima dell'effettiva comparsa sullo schermo.
Immediatamente prima della transizione della scena sullo schermo, viene inviato un evento show che utilizza un paramatro "will". Questa è una grande opportunità per reimpostare i valori delle variabili o riposizionare oggetti che potrebbero essersi spostati dalla loro posizione iniziale prevista dall'ultima volta che la scena è stata mostrata. Una volta che la scena è completamente sullo schermo, un altro evento viene inviato alla scena: la funzione show () con un parametro di fase uguale a "did", questa è ora considerata la scena attiva.
La funzione "scene:hide()" è composta anch'essa da due fasi: una fase "will", quando la scena è sullo schermo (ma sta per uscire); ed una fase "did", immediatamente dopo che la scena esce dallo schermo. Se viene specificato un effetto di transizione o sovrapposizione per la nuova scena , la fase "will" viene inviata prima che l'effetto inizi l'esecuzione e la fase "did" viene inviata dopo che l'effetto è terminato.
Quando si esce dalla scena, la funzione che viene richiamata per eliminare gli oggetti è "scene:destroy" (nel programma in questione questa funzione non è stata necessaria). 
\\


Le varie scene sono rapprsentate da dei file.lua, che verranno chiamati mediante la funzione del composer gotoScene() citata in precedenza, in particolare:
\begin{itemize}
    \item menu.lua
    \item game.lua
\end{itemize}



La schermata iniziale del gioco raffigura il menù, composto da tre pulsanti principali: il pulsante "play" che avvia la partita vera e propria; il pulsante "scores" che mostra i punteggi più alti ottenuti; ed infine il pulsante "about" che mostra le informazioni sugli sviluppatori ed il link al git se si volesse contribuire al progetto. \\
\begin{center}
    \includegraphics[width=80mm]{menu.png}\\
\end{center}

Oltre ai 3 pulsanti principali, c'è anche un pulsante secondario raffigurato mediante un ingranaggio. Cliccandoci sopra si apre un menù a tendina che contiene altri 4 pulsanti:
\begin{itemize}
    \item uno realtivo alla scelta delle diverse skin del sottomarino; 
\begin{center}
    \includegraphics[width=80mm]{skin.png}\\
\end{center}
    \item uno che mostra i vari ambienti di gioco selezionabili; 

\begin{center}
    \includegraphics[width=80mm]{ambienti.png}\\
\end{center}


    \item uno che permette la scelta del colore delle bolle che usciranno dal sottomarino. 
\\
\begin{center}
    \includegraphics[width=80mm]{bolle.png}\\
\end{center}

    \item infine uno che disabilita l'audio musicale. 
\end{itemize}
\section{Game.lua}
Dopo aver premuto il pulsante play si passa al file "game.lua", in cui vengono realizzati tutti gli oggetti ed il codice relativo 
alla realizzazione della logica del gioco. 
\subsection{create()}
Nella funzione create(), inzialmente vengono settate le variabili legate al composer: "startTime" è utilizzata per calcolare la 
velocità dello schermo in base al tempo; "gameSpeed", imposta la velocità iniziale di scorrimento dello schermo a 1. 
ale velocità viene aggiornata ogni 1000 ms tramite un listener che chiama la funzione updateGameSpeed. 
La scelta del valore 1000ms non è casuale, ma è stato inserito in modo tale da non accumulare troppo l'incremento in quel secondo.
\\

Le collisioni tra sottomarino ed oggetti da raccogliere sono gestite a tempo di esecuzione mediante un listener, in questo modo ogni volta che avviene una collisione viene chiamata la funzione onCollision(). 
\\

Il punteggio viene rappresentato mediante un "display object" in cui è stato utilizzato il font di default salvato in una variabile locale in modo tale da renderlo più accessibile in tutte le parti del programma. 

\\
La vita del mare viene creata usando la funzione newProgressView in cui vengono inseriti 3 parametri:
\begin{itemize}
    \item percetuale della vita: rappresentata da un valore all'interno dell'intervallo [0,1] in cui 1 rappresenta il 100 e 0 lo 0. La barra viene creata inizialmente al 100.
    \item posizione della barra a seconda dell'asse X (inizialmente posta al centro dell'asse X)
    \item posizione della barra a seconda dell'asse Y
\end{itemize}
La percentuale di progresso della barra viene gestita da un metodo setProgress inserito all'interno della funzione newProgressView. Inoltre la vita del mare viene aggiornata utilizzando un timer: ogni secondo abbassa la vita del mare in funzione della quantità di oggetti che sono fuoriusciti dalla parte sinsitra schermo, e che quindi non sono stati raccolti dal sottomarino. La quantità di vita perduta è proporzionale al valore dell'oggetto perso.

\subsection{show()}
L'evento show() ha due sottoeventi chiamati "will" e "did". Nel "will" si aggiunge il timer che va ad aggiornare il moltiplicatore di punteggio: ogni 30 secondi si aggiunge 0.25 al moltiplicatore dei punti e la funzione che fa tutto questo è updateScoreMultiplier(). Il codice del sottoevento "did" viene eseguito quando la scena è visualizzata sullo schermo, e come prima cosa viene fatta partire la fisica, altrimenti il gioco inizierebbe con il sottomarino sulla parte bassa dello schermo. Inoltre in questa fase si carica il modulo relativo allo "spawner" dei vari oggetti(bottigliette, barili, scogli) e al caricamento dell'audio (la musica e i vari effetti sonori).

\subsection{hide()}
Evento hide() viene usato per nascondere la scena, in particolare le sue funzioni vengono chiamate nella fase "did". Quando la scena è completamente off-screen, vengono eliminati i listener RunTime e i timer creati in precedenza. Una funzione particolarmente importante è "removeScene()" che rimuove completamente la scena, tutti gli oggetti e le variabili al suo interno,
in particolare si occupa degli gli oggetti all'interno della gerarchia di sceneGroup (NOTA: non rimuove cose come timer o listener collegati all'oggetto "Runtime". Essi vengono eliminati manualmente).

\subsection{destroy()}
L'evento destroy() viene utilizzato per eliminare l'audio prima della rimozione della scena.

\subsection{Breve analisi di alcune funzioni interessanti}
In questo paragrafo verranno descritte le funzionalità implementate per realizzare le funzionalità citate in precedenza.
\subsubsection{updateGameSpeed()}
La funzione che aggiorna la velocità di scorrimento dello schermo è chiamata "updateGameSpeed". Nella variabile "gs" viene memorizzata la velocità iniziale (impostata inizialmente a 1). Tale valore viene confrontato periodicamente (ogni 30 secondi) con la velocità massima raggiungibile (maxGameSpeed = 3) e, se strettamente minore, la variabile gs viene aggiornata in funzione del tempo trascorso mediante la formula:\\

\begin{center}
    gs = 1 + ( (os.time() - st) / 100 )
\end{center}

\\

Dove \textbf{st} è lo "start time" mentre \textbf{os.time()} è una funzione che restituisce l'ora corrente in secondi a partire dal 1970.

\subsubsection{gameOver()}
La procedura gameOver(), si occupa di gestire il caso in cui la partita termini: ovvero quando si va a sbattere contro uno scoglio oppure quando la vita del mare cala fino a raggiungere lo 0\%. Quando si verifica uno di questi due casi, la variabile isGameOver assume valore "true" e si interrompono tutti i suoni, la fisica del gioco, il movimento del background. A quel punto viene visualizzato sullo schermo un background una schermata nera di Game Over e la scena viene reindirizzata al menù principale.

\subsubsection{onCollision()}
Per realizzare la procedura che gestisce la collisione tra gli oggetti è stato applicato il metodo dei filtri. 
Questo metodo implica l'assegnazione di \textbf{categoryBits} e \textbf{maskBits} agli oggetti tramite una definizione di una 
tabella assegnata al filtro durante la costruzione del corpo. Un oggetto entrerà in collisione con altri oggetti solo se i loro 
categoryBits sono tra i maskBits assegnati. Normalmente, un oggetto avrà solo un valore di categoryBits assegnato, ma potrebbe avere 
uno o più mskBits a seconda delle altre cose con cui dovrebbe entrare in collisione.

\begin{center}
    \includegraphics[width=110mm]{tabella2.png}\\
\end{center}

I parametri dei filtri sono stati impostati come "globali" sul composer, in quanto se in un secondo momento si aggiungono ulteriori 
elementi di gioco, è necessario lavorare di nuovo su tutti i tipi di oggetto, perché se il nuovo tipo di oggetto dovesse entrare in 
collisione con qualsiasi tipo di oggetto precedente, i valori per quest'ultimo potrebbero cambiare. 


\subsubsection{clearObject()}
Questa procedura si occupa di rimuovere tutti gli oggetti che escono dalla parte sinistra dello schermo (quindi quelli che non sono stati raccolti dall'utente) mediante le operazioni display.remove( thisObject ) e table.remove( screenObjectsTable, i). ScreenObjectTable è una tabella in cui vengono messi tutti gli oggetti di gioco creati e quando si eliminano, vengono anche rimossi da questa tabella. \\
Il ciclo for viene fatto partire dalla posizione finale della tabella, in quanto la funzione table.remove() è inefficiente (rimuovendo un oggetto dalla tabella, bisogna shiftare tutti gli oggetti in basso di una posizione in modo da mantenere la tabella compatta)

\subsubsection{updateSeaLife()}
Quando un oggetto non viene raccolto dall'utente la vita del mare cala del valore dell'oggetto perduto (ogni oggetto ha un valore differente). Questa funzione si occupa di aggiornare la vita quando si verifica la condizione appena citata ed utilizza la stessa tabella utilizzata nella funzione clearObject().\\
Per avere una risposta più rapida sulla barra della vita del mare in questo caso si va a contare la vita persa quando la coordinata "x" dell'oggetto diventa minore di 0.\\

Per ogni displayObject (quelli che si possono raccogliere) viene definito un attributo "mySeaLife", che viene utilizzato per evitare di contare più volte la vita del mare persa in base a questi oggetti (finchè l'oggetto, dopo essere uscito dallo schermo, non raggiunge -800, ogni volta che si va a richiamare il controllo per aggiornare la vita del mare si diminuisce la vita del valore di quell'oggetto). Quando il seaLife è minore o uguale a 0, si richiama la funzione di gameOver().\\

Il controllo "isGameOver == false" viene fatto perchè altrimenti i suoni verrebbero riprodutti più volte. 




\section{Menu.lua}
La seconda scena più importante del gioco è quella del menù, la cui implementazione è realizzata all'interno del file "Menù.lua". Questo modulo usa come ausilio le liberire citate al capitolo 4. Al suo interno per prima cosa vengono dichiarati tutte le variabili relative ai moduli e relative agli assets che verranno visualizzati.

\subsection{create()}
La funzione create() comincia la sua esecuzione impostando le variabili dei "displayObjects" degli oggetti da visualizzare (background e Ui). 
\\

Dopo di che viene gestita la velocità del background (inizialmente impostata a 0.1) all'interno della finestra del menù. Essendo la velocità impostata a 0.1, il background si muoveva molto lentamente, in modo tale da dare la sensazione di trovarsi effettivamente sott'acqua. A questo proposito viene usata la funzione "timer.performWithDelay()", che chiama una funzione specifica (BackgroundSpeedUpdate) dopo un intervallo di tempo stabilito. Tale funzione viene utilizzata per invertire il verso di scorrimento del background dopo un delay di 4 secondi. 
\\

Nel create vengono inserite le immagini relative al titolo da visualizzare ed i vari pulsanti (play, scores, about...). Le immagini degli assets sono memorizzate all'interno di una cartella, e vengono caricate all'interno del gioco mediante la funzione "display.newImageRect" in cui si indica: il groupObject in cui inserire l'immagine; il file da cui caricare l'immagine; la directory di base in cui si trova filename; larghezza dell'immagine; l'altezza dell'immagine. 




\section{Difficoltà riscontrate}


\end{document}